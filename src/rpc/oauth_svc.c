/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "oauth.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "../data/server_model/server_model.h"
#include <iostream>

#ifndef SIG_PF
#define SIG_PF void (*)(int)
#endif

static void
oauth_protocol_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union
	{
		char *request_authorization_1_arg;
		access_token_request_t request_access_token_1_arg;
		delegated_action_request_t validate_delegated_action_1_arg;
		request_authorization_t approve_request_token_1_arg;
		access_token_t refresh_access_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc)
	{
	case NULLPROC:
		(void)svc_sendreply(transp, (xdrproc_t)xdr_void, (char *)NULL);
		return;

	case request_authorization:
		_xdr_argument = (xdrproc_t)xdr_wrapstring;
		_xdr_result = (xdrproc_t)xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *))request_authorization_1_svc;
		break;

	case request_access_token:
		_xdr_argument = (xdrproc_t)xdr_access_token_request_t;
		_xdr_result = (xdrproc_t)xdr_access_token_t;
		local = (char *(*)(char *, struct svc_req *))request_access_token_1_svc;
		break;

	case validate_delegated_action:
		_xdr_argument = (xdrproc_t)xdr_delegated_action_request_t;
		_xdr_result = (xdrproc_t)xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *))validate_delegated_action_1_svc;
		break;

	case approve_request_token:
		_xdr_argument = (xdrproc_t)xdr_request_authorization_t;
		_xdr_result = (xdrproc_t)xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *))approve_request_token_1_svc;
		break;

	case refresh_access:
		_xdr_argument = (xdrproc_t)xdr_access_token_t;
		_xdr_result = (xdrproc_t)xdr_access_token_t;
		local = (char *(*)(char *, struct svc_req *))refresh_access_1_svc;
		break;

	default:
		svcerr_noproc(transp);
		return;
	}
	memset((char *)&argument, 0, sizeof(argument));
	if (!svc_getargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		svcerr_decode(transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t)_xdr_result, result))
	{
		svcerr_systemerr(transp);
	}
	if (!svc_freeargs(transp, (xdrproc_t)_xdr_argument, (caddr_t)&argument))
	{
		fprintf(stderr, "%s", "unable to free arguments");
		exit(1);
	}
	return;
}

void readUsersFile(char *file)
{
	// Open file with fopen
	FILE *fp = fopen(file, "r");
	if (fp == NULL)
	{
		printf("Could not open file %s\n", file);
		exit(1);
	}

	// Read first line as number of users
	int num_users;
	fscanf(fp, "%d\n", &num_users);

	// Read each user and add to user_list
	for (int i = 0; i < num_users; i++)
	{
		char user[100];
		fscanf(fp, "%s\n", user);
		user_list.push_back(user);
	}
}

void readResourcesFile(char *file)
{
	// Open file with fopen
	FILE *fp = fopen(file, "r");
	if (fp == NULL)
	{
		printf("Could not open file %s\n", file);
		exit(1);
	}

	// Read first line as number of resources
	int num_resources;
	fscanf(fp, "%d\n", &num_resources);

	// Read each resource and add to resource_list
	for (int i = 0; i < num_resources; i++)
	{
		char resource[100];
		fscanf(fp, "%s\n", resource);
		resource_list.push_back(resource);
	}
}

void readApprovalsFile(char *file, std::vector<std::string> user_list)
{
	// Open file with fopen
	FILE *fp = fopen(file, "r");
	if (fp == NULL)
	{
		printf("Could not open file %s\n", file);
		exit(1);
	}

	int user_counter = 0;

	// Read each line and add to approvals_list
	while (!feof(fp))
	{
		// Approvals come as format <resource>, <permission>, <resource>, <permission>, ...
		char line[1000];
		fscanf(fp, "%s\n", line);

		// Map for approvals of a user
		std::unordered_map<std::string, std::string> user_approvals;

		// Split line by comma
		int word_counter = 0;
		char *token = strtok(line, ",");
		char *resource = NULL;
		while (token != NULL)
		{
			// If counter is even, it is a resource
			if (word_counter % 2 == 0)
			{
				resource = token;
			}
			// If counter is odd, it is a permission
			else
			{
				// Transform resource and permission to string
				std::string resource_str(resource);
				std::string permission_str(token);

				// Add to user_approvals
				user_approvals[resource_str] = permission_str;
			}
			word_counter++;
			token = strtok(NULL, ",");
		}

		user_to_approvals_list.push_back(user_approvals);
		user_counter++;
	}
}

int main(int argc, char **argv)
{
	register SVCXPRT *transp;
	if (argc < 5)
	{
		printf("Wrong usage. Correct usage: %s <users_file> <resources_file> <approvals_file> "
			   "<token_lifetime>\n",
			   argv[0]);
		exit(1);
	}

	readUsersFile(argv[1]);
	readResourcesFile(argv[2]);
	readApprovalsFile(argv[3], user_list);

	// Set global token lifetime
	global_token_lifetime = atoi(argv[4]);

	pmap_unset(OAUTH_PROTOCOL, OAUTH_VERSION);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, OAUTH_PROTOCOL, OAUTH_VERSION, oauth_protocol_1, IPPROTO_UDP))
	{
		fprintf(stderr, "%s", "unable to register (OAUTH_PROTOCOL, OAUTH_VERSION, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL)
	{
		fprintf(stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, OAUTH_PROTOCOL, OAUTH_VERSION, oauth_protocol_1, IPPROTO_TCP))
	{
		fprintf(stderr, "%s", "unable to register (OAUTH_PROTOCOL, OAUTH_VERSION, tcp).");
		exit(1);
	}

	svc_run();
	fprintf(stderr, "%s", "svc_run returned");
	exit(1);
	/* NOTREACHED */
}
