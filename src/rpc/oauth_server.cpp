/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "../../data/server_model/server_model.h"
#include "../client_driver/operations/operation.hpp"
#include "../utils/token.h"
#include "../utils/res_codes.hpp"
#include <iostream>
#include <algorithm>

void log_to_file(const std::string &message, const std::string &filename)
{
	std::ofstream log_file(filename, std::ios_base::app);
	log_file << message << std::endl;
}

void log(const std::string &message, int level = 0)
{
	switch (level)
	{
	case 1:
		log_to_file(message, "client_global_logging_file.txt");
		break;
	case 2:
		log_to_file(message, "server_global_logging_file.txt");
		break;
	default:
		std::cout << message << std::endl;
		break;
	}
}

bool user_exists(const std::string &user_id)
{
	return std::find(user_list.begin(), user_list.end(), user_id) != user_list.end();
}

char *generate_and_log_token(const std::string &user_id)
{
	char *user_id_copy = strdup(user_id.c_str()); // Duplicate to get a non-const char*
	char *token = generate_access_token(user_id_copy);
	free(user_id_copy); // Free the duplicated string after use

	log("Token generated: " + std::string(token), 2);
	return token;
}

char **request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	log("========= REQUEST AUTHORIZATION =========", 2);

	std::string user_id = argp[0];

	if (user_exists(user_id))
	{
		log("User found", 2);
		result = generate_and_log_token(user_id);
	}
	else
	{
		log("User not found", 2);
		result = strdup(ResponseCodes::getString(ResponseCodes::USER_NOT_FOUND).c_str());
	}
	return &result;
}

void set_error_response(access_token_t &result, const std::string &code)
{
	result.access_token = strdup(code.c_str());
	result.refresh_token = strdup(code.c_str());
	result.expiration = -1;
}

bool token_exists(const std::string &token_str)
{
	return std::any_of(auth_token_list.begin(), auth_token_list.end(),
					   [&token_str](const Token &token)
					   {
						   return token.get_token() == token_str;
					   });
}

Token *get_signed_token(const std::string &token_str)
{
	for (Token &token : auth_token_list)
	{
		if (token.get_token() == token_str && token.get_status() == Token::AUTH_SIGNED)
		{
			return &token;
		}
	}
	return nullptr;
}

std::string generate_refresh_token(const std::string &access_token)
{
	char *access_token_copy = strdup(access_token.c_str());
	std::string refresh_token = generate_access_token(access_token_copy);
	free(access_token_copy); // Free the duplicated string
	return refresh_token;
}

void add_access_token_to_user(const std::string &user_id, const Token &access_token)
{
	log("Adding access token " + access_token.get_token() + " to user " + user_id, 2);
	user_to_access_token[user_id] = access_token;
}

access_token_t *request_access_token_1_svc(access_token_request_t *argp, struct svc_req *rqstp)
{
	static access_token_t result;
	std::string user_id = argp->user_id;
	std::string token_received = argp->authentification_token;
	int auto_refresh = argp->auto_refresh;

	log("BEGIN " + user_id + " AUTHZ", 0);

	if (!user_exists(user_id))
	{
		log("User not found. Returning USER_NOT_FOUND", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::USER_NOT_FOUND));
		return &result;
	}

	log("  RequestToken = " + token_received, 0);
	log("========= REQUEST ACCESS TOKEN =========", 2);

	Token *token = get_signed_token(token_received);
	if (!token)
	{
		log("Token not found or not signed. Returning REQUEST_DENIED", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::REQUEST_DENIED));
		return &result;
	}

	log("Token found and signed. Generating access token", 2);

	// Convert `token_received` to `char*` for `generate_access_token`
	char *token_received_copy = strdup(token_received.c_str());
	std::string access_token_str = generate_access_token(token_received_copy);
	free(token_received_copy); // Free the copy after use

	Token access_token(access_token_str, user_id, global_token_lifetime, Token::ACCESS);
	access_token.add_approvals(token->get_approvals());

	if (auto_refresh)
	{
		log("Auto-refresh enabled. Generating refresh token", 2);
		std::string refresh_token = generate_refresh_token(access_token_str);
		access_token.add_refresh_token(refresh_token);
		result.refresh_token = strdup(refresh_token.c_str());
	}
	else
	{
		result.refresh_token = strdup("NULL");
	}

	add_access_token_to_user(user_id, access_token);

	// Check approvals for permission
	auto approvals = access_token.get_approvals();
	if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
	{
		log("No approvals found. Returning REQUEST_DENIED", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::REQUEST_DENIED));
		return &result;
	}

	// Set access token response
	result.access_token = strdup(access_token_str.c_str());
	result.expiration = global_token_lifetime;

	log("  AccessToken = " + access_token_str, 0);
	if (auto_refresh)
		log("  RefreshToken = " + std::string(result.refresh_token), 0);

	return &result;
}

char **
validate_delegated_action_1_svc(delegated_action_request_t *argp, struct svc_req *rqstp)
{
	static char *result;

	// parse the arguments
	std::string operation_type = argp->operation_type;
	std::string resource = argp->resource;
	std::string access_token_str = argp->access_token;

	log("========= VALIDATE DELEGATED ACTION =========", 2);
	log("Validating delegated action for user with access token " + access_token_str + " for operation " + operation_type + " on resource " + resource, 2);

	// if access_token_str is "" print a DENY (Operation,Resource,access_tokien,valability) and return a PERMISSION_DENIED error
	if (access_token_str == "")
	{
		log("Access token is empty. Returning PERMISSION_DENIED", 2);
		log("DENY (" + operation_type + "," + resource + "," + access_token_str + ",0)", 0);
		result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_DENIED).c_str());
		return &result;
	}

	// check if the access token is in the user_to_access_token map
	for (auto const &user_access_token : user_to_access_token)
	{
		Token user_access_token_i = user_access_token.second;
		log("Comparing " + user_access_token_i.get_token() + " with " + access_token_str, 2);
		if (user_access_token_i.get_token() == access_token_str)
		{
			// get the access token based on the user id
			Token access_token = user_to_access_token[user_access_token.first];

			// based on the token, find the token in the
			log("Access token with id " + access_token_str + " with lifetime " + std::to_string(access_token.get_lifetime()) + " found for user " + user_access_token.first, 2);

			// check if the token is expired
			if (access_token.get_lifetime() <= 0)
			{
				log("Access token expired", 2);
				// log to stream 0 DENY (Operaion,Resource,access_token,validity)
				log("DENY (" + operation_type + "," + resource + "," + ",0)", 0);
				result = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
				return &result;
			}

			// decrease the lifetime of the token
			user_to_access_token[user_access_token.first].decrease_lifetime();
			access_token.decrease_lifetime();

			// if operation type is not in the macros then send an OPERATION_NOT_PERMITTED error
			if (operation_type != REQUEST && operation_type != MODIFY && operation_type != INSERT && operation_type != DELETE && operation_type != READ && operation_type != NO_RESOURCE && operation_type != EXECUTE)
			{
				log("Operation type not found. Returning OPERATION_NOT_PERMITTED", 2);
				log("DENY (" + operation_type + "," + resource + "," + access_token_str + "," + std::to_string(access_token.get_lifetime()) + ")", 0);
				result = strdup(ResponseCodes::getString(ResponseCodes::OPERATION_NOT_PERMITTED).c_str());
				return &result;
			}

			// check if the resource exists in the resource_list
			if (std::find(resource_list.begin(), resource_list.end(), resource) == resource_list.end())
			{
				log("Resource not found", 2);
				// log to stream 0 DENY (Operaion,Resource,access_token,validity)
				log("DENY (" + operation_type + "," + resource + "," + access_token_str + "," + std::to_string(access_token.get_lifetime()) + ")", 0);
				result = strdup(ResponseCodes::getString(ResponseCodes::RESOURCE_NOT_FOUND).c_str());
				return &result;
			}

			// check if the user has the permission to perform the action
			std::unordered_map<std::string, std::string> approvals = access_token.get_approvals();

			// log if the approvals are empty
			if (approvals.empty())
			{
				log("No approvals found for the user", 2);
			}

			// print the approvals
			for (auto const &approval : approvals)
			{
				log("Approval: " + approval.first + " " + approval.second, 2);
			}

			log("Searching for operation type " + operation_type + " in the approvals", 2);

			// if the resource appears in approvals and the operation type lets say "D" for delete appears in the approvals string of that resource
			if (approvals.find(resource) != approvals.end() && approvals[resource].find(access_token.get_operation_to_code()[operation_type]) != std::string::npos)
			{
				log("User has the permission to perform the action", 2);
				// log to stream 0 PERMIT (Operaion,Resource,access_token,validity)
				log("PERMIT (" + operation_type + "," + resource + "," + access_token_str + "," + std::to_string(access_token.get_lifetime()) + ")", 0);
				result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_GRANTED).c_str());
				return &result;
			}
			else
			{
				log("User does not have the permission to perform the action", 2);
				// log to stream 0 DENY (Operaion,Resource,access_token,validity)
				log("DENY (" + operation_type + "," + resource + "," + access_token_str + "," + std::to_string(access_token.get_lifetime()) + ")", 0);
				result = strdup(ResponseCodes::getString(ResponseCodes::OPERATION_NOT_PERMITTED).c_str());
				return &result;
			}
		}
	}

	// if the access token is not found return an error
	log("Access token not found", 2);
	// log to stream 0 DENY (Operaion,Resource,access_token,validity)
	log("DENY (" + operation_type + "," + resource + "," + access_token_str + ", 0)", 0);
	result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_DENIED).c_str());
	return &result;
}

char **
approve_request_token_1_svc(request_authorization_t *argp, struct svc_req *rqstp)
{
	static char *result;

	std::string token_received = argp->authentification_token;
	std::string user_id_str = argp->user_id;
	int refresh_token = argp->refresh_token;

	log("========= APPROVE REQUEST TOKEN =========", 2);
	log("Request signature for token: " + token_received + " for user " + user_id_str + " with refresh token " + std::to_string(refresh_token), 2);

	// if we find the token in the list
	for (Token token : auth_token_list)
	{
		if (token.get_token() == token_received)
		{
			// if the token is signed
			if (token.get_status() == Token::AUTH_SIGNED)
			{
				log("Token already signed. Returning the token", 2);
				// return the token
				strcpy(result, token.get_token().c_str());
				return &result;
			}
			else
			{
				log("Found token as not signed. Signing the token", 2);
				// based on the approvals the user has in user_to_approvals_list, add them to the token
				// make user_id from argp string
				std::unordered_map<std::string, std::string> approvals = user_to_approvals_list.back();
				user_to_approvals_list.pop_back();

				// if there are no approvals return token as unsigned
				if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
				{
					log("No approvals found for user " + user_id_str, 2);
					strcpy(result, token_received.c_str());
					return &result;
				}

				log("Adding approvals to token for user " + user_id_str, 2);
				token.add_approvals(approvals);

				// if the token is unsigned, sign it
				log("Signing the token and returning it", 2);
				token.sign();

				// return the token
				strcpy(result, token.get_token().c_str());
				return &result;
			}
		}
	}

	// return the token unchanged if no approvals are to be added
	log("Token not found. Adding it to the list", 2);
	Token token = Token(argp->authentification_token, user_id_str, global_token_lifetime, Token::AUTH_UNSIGNED);

	// based on the approvals the user has in user_to_approvals_list, add them to the token
	std::unordered_map<std::string, std::string> approvals = user_to_approvals_list[0];
	user_to_approvals_list.erase(user_to_approvals_list.begin());

	// if there are no approvals return token as unsigned
	if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
	{
		log("No approvals found for user " + user_id_str, 2);
		strcpy(result, token_received.c_str());
		return &result;
	}

	log("Adding approvals to token for user " + user_id_str, 2);
	token.add_approvals(approvals);

	// if the token is unsigned, sign it
	log("Signing the token and returning it", 2);
	token.sign();

	// add the token to the list
	auth_token_list.push_back(token);

	std::string result_str = token.get_token();
	result = strdup(result_str.c_str());

	return &result;
}

access_token_t *
refresh_access_1_svc(access_token_t *argp, struct svc_req *rqstp)
{
	// find the user id based on the access token
	std::string user_id;
	for (auto const &user_access_token : user_to_access_token)
	{
		Token user_access_token_i = user_access_token.second;
		if (user_access_token_i.get_token() == argp->access_token)
		{
			user_id = user_access_token.first;
			break;
		}
	}

	// log in stream 0 BEGIN user_id AUTHZ REFRESH
	log("BEGIN " + user_id + " AUTHZ REFRESH", 0);
	static access_token_t result;

	// parse the arguments
	std::string access_token_str = argp->access_token;
	std::string refresh_token_str = argp->refresh_token;

	log("========= REFRESH ACCESS TOKEN =========", 2);
	log("Refresh access token with access token " + access_token_str + " and refresh token " + refresh_token_str, 2);

	// find the access token in the user_to_access_token map
	for (auto const &user_access_token : user_to_access_token)
	{
		Token user_access_token_i = user_access_token.second;
		if (user_access_token_i.get_token() == access_token_str)
		{
			log("Access token found. Refreshing it", 2);

			// generate a new access token
			std::string new_access_token = generate_access_token(strdup(refresh_token_str.c_str()));

			// generate a new refresh token
			std::string new_refresh_token = generate_access_token(strdup(new_access_token.c_str()));

			// generate a new access token instance
			Token new_access_token_i = Token(new_access_token, new_refresh_token, user_access_token_i.get_user_id(), global_token_lifetime, Token::ACCESS);
			new_access_token_i.copy_all_approvals(user_access_token_i);

			// update the access token in the user_to_access_token map
			user_to_access_token[user_access_token.first] = new_access_token_i;

			// return the new access token
			result.access_token = strdup(new_access_token.c_str());
			result.refresh_token = strdup(new_refresh_token.c_str());
			result.expiration = global_token_lifetime;

			log("  AccessToken = " + new_access_token, 0);
			log("  RefreshToken = " + new_refresh_token, 0);

			return &result;
		}
	}

	// if the access token is not found return an error
	log("Access token not found. Could not refresh it", 2);
	result.access_token = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
	result.refresh_token = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
	result.expiration = -1;

	return &result;
}
