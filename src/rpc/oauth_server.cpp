/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "../../data/server_model/server_model.h"
#include "../client_driver/operations/operation.hpp"
#include "../utils/token.h"
#include "../utils/res_codes.hpp"
#include <iostream>
#include <algorithm>

void log_to_file(const std::string &message, const std::string &filename)
{
	std::ofstream log_file(filename, std::ios_base::app);
	log_file << message << std::endl;
}

void log(const std::string &message, int level = 0)
{
	switch (level)
	{
	case 1:
		log_to_file(message, "client_global_logging_file.txt");
		break;
	case 2:
		log_to_file(message, "server_global_logging_file.txt");
		break;
	default:
		std::cout << message << std::endl;
		break;
	}
}

bool user_exists(const std::string &user_id)
{
	return std::find(user_list.begin(), user_list.end(), user_id) != user_list.end();
}

char *generate_and_log_token(const std::string &user_id)
{
	char *user_id_copy = strdup(user_id.c_str()); // Duplicate to get a non-const char*
	char *token = generate_access_token(user_id_copy);
	free(user_id_copy); // Free the duplicated string after use

	log("Token generated: " + std::string(token), 2);
	return token;
}

char **request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	log("========= REQUEST AUTHORIZATION =========", 2);

	std::string user_id = argp[0];

	if (user_exists(user_id))
	{
		log("User found", 2);
		result = generate_and_log_token(user_id);
	}
	else
	{
		log("User not found", 2);
		result = strdup(ResponseCodes::getString(ResponseCodes::USER_NOT_FOUND).c_str());
	}
	return &result;
}

void set_error_response(access_token_t &result, const std::string &code)
{
	result.access_token = strdup(code.c_str());
	result.refresh_token = strdup(code.c_str());
	result.expiration = -1;
}

bool token_exists(const std::string &token_str)
{
	return std::any_of(auth_token_list.begin(), auth_token_list.end(),
					   [&token_str](const Token &token)
					   {
						   return token.get_token() == token_str;
					   });
}

Token *get_signed_token(const std::string &token_str)
{
	for (Token &token : auth_token_list)
	{
		if (token.get_token() == token_str && token.get_status() == Token::AUTH_SIGNED)
		{
			return &token;
		}
	}
	return nullptr;
}

std::string generate_refresh_token(const std::string &access_token)
{
	char *access_token_copy = strdup(access_token.c_str());
	std::string refresh_token = generate_access_token(access_token_copy);
	free(access_token_copy); // Free the duplicated string
	return refresh_token;
}

void add_access_token_to_user(const std::string &user_id, const Token &access_token)
{
	log("Adding access token " + access_token.get_token() + " to user " + user_id, 2);
	user_to_access_token[user_id] = access_token;
}

access_token_t *request_access_token_1_svc(access_token_request_t *argp, struct svc_req *rqstp)
{
	static access_token_t result;
	std::string user_id = argp->user_id;
	std::string token_received = argp->authentification_token;
	int auto_refresh = argp->auto_refresh;

	log("BEGIN " + user_id + " AUTHZ", 0);

	if (!user_exists(user_id))
	{
		log("User not found. Returning USER_NOT_FOUND", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::USER_NOT_FOUND));
		return &result;
	}

	log("  RequestToken = " + token_received, 0);
	log("========= REQUEST ACCESS TOKEN =========", 2);

	Token *token = get_signed_token(token_received);
	if (!token)
	{
		log("Token not found or not signed. Returning REQUEST_DENIED", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::REQUEST_DENIED));
		return &result;
	}

	log("Token found and signed. Generating access token", 2);

	// Convert `token_received` to `char*` for `generate_access_token`
	char *token_received_copy = strdup(token_received.c_str());
	std::string access_token_str = generate_access_token(token_received_copy);
	free(token_received_copy); // Free the copy after use

	Token access_token(access_token_str, user_id, global_token_lifetime, Token::ACCESS);
	access_token.add_approvals(token->get_approvals());

	if (auto_refresh)
	{
		log("Auto-refresh enabled. Generating refresh token", 2);
		std::string refresh_token = generate_refresh_token(access_token_str);
		access_token.add_refresh_token(refresh_token);
		result.refresh_token = strdup(refresh_token.c_str());
	}
	else
	{
		result.refresh_token = strdup("NULL");
	}

	add_access_token_to_user(user_id, access_token);

	// Check approvals for permission
	auto approvals = access_token.get_approvals();
	if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
	{
		log("No approvals found. Returning REQUEST_DENIED", 2);
		set_error_response(result, ResponseCodes::getString(ResponseCodes::REQUEST_DENIED));
		return &result;
	}

	// Set access token response
	result.access_token = strdup(access_token_str.c_str());
	result.expiration = global_token_lifetime;

	log("  AccessToken = " + access_token_str, 0);
	if (auto_refresh)
		log("  RefreshToken = " + std::string(result.refresh_token), 0);

	return &result;
}

#include <string>
#include <unordered_map>
#include <vector>

// Helper to log validation result at level 0, with optional handling for empty or expired tokens
void log_validation_result(const std::string &status, const std::string &operation_type,
						   const std::string &resource, const std::string &access_token_str, int validity, bool omit_token = false)
{
	std::string log_message = status + " (" + operation_type + "," + resource + ",";
	log_message += omit_token ? "" : access_token_str;
	log_message += "," + std::to_string(validity) + ")";
	log(log_message, 0);
}

// Helper to check if the access token is empty
bool is_empty_token(const std::string &access_token_str, const std::string &operation_type, const std::string &resource, char *&result)
{
	if (access_token_str.empty())
	{
		log("Access token is empty. Returning PERMISSION_DENIED", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, 0);
		result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_DENIED).c_str());
		return true;
	}
	return false;
}

// Helper to find the token in user_to_access_token map
bool find_access_token(const std::string &access_token_str, Token &access_token, std::string &user_id)
{
	for (const auto &user_access_token : user_to_access_token)
	{
		if (user_access_token.second.get_token() == access_token_str)
		{
			access_token = user_access_token.second;
			user_id = user_access_token.first;
			return true;
		}
	}
	return false;
}

// Helper to check if the token is expired
bool is_token_expired(Token &access_token, const std::string &operation_type, const std::string &resource,
					  const std::string &access_token_str, char *&result)
{
	if (access_token.get_lifetime() <= 0)
	{
		log("Access token expired", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, 0);
		result = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
		return true;
	}
	return false;
}

// Helper to validate operation type
bool is_valid_operation(const std::string &operation_type)
{
	return operation_type == REQUEST || operation_type == MODIFY || operation_type == INSERT ||
		   operation_type == DELETE || operation_type == READ || operation_type == NO_RESOURCE ||
		   operation_type == EXECUTE;
}

// Helper to check if the resource exists
bool is_valid_resource(const std::string &resource)
{
	return std::find(resource_list.begin(), resource_list.end(), resource) != resource_list.end();
}

// Helper to check if the user has the required approval
bool has_required_approval(const Token &access_token, const std::string &resource, const std::string &operation_type)
{
	const auto &approvals = access_token.get_approvals();
	auto it = approvals.find(resource);
	return it != approvals.end() && it->second.find(access_token.get_operation_to_code()[operation_type]) != std::string::npos;
}

char **validate_delegated_action_1_svc(delegated_action_request_t *argp, struct svc_req *rqstp)
{
	static char *result;

	// Parse the arguments
	std::string operation_type = argp->operation_type;
	std::string resource = argp->resource;
	std::string access_token_str = argp->access_token;

	log("========= VALIDATE DELEGATED ACTION =========", 2);
	log("Validating delegated action for user with access token " + access_token_str +
			" for operation " + operation_type + " on resource " + resource,
		2);

	// Check if the access token is empty
	if (access_token_str.empty())
	{
		log("Access token is empty. Returning PERMISSION_DENIED", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, 0, /*omit_token=*/true);
		result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_DENIED).c_str());
		return &result;
	}

	// Find the access token
	Token access_token;
	std::string user_id;
	if (!find_access_token(access_token_str, access_token, user_id))
	{
		log("Access token not found", 2);
		log_validation_result("DENY", operation_type, resource, "", 0, /*omit_token=*/true);
		result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_DENIED).c_str());
		return &result;
	}

	log("Access token with id " + access_token_str + " with lifetime " +
			std::to_string(access_token.get_lifetime()) + " found for user " + user_id,
		2);

	// Check if the token is expired
	if (access_token.get_lifetime() <= 0)
	{
		log("Access token expired", 2);
		log_validation_result("DENY", operation_type, resource, "", 0, /*omit_token=*/true);
		result = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
		return &result;
	}

	// Decrease the lifetime of the token
	user_to_access_token[user_id].decrease_lifetime();
	access_token.decrease_lifetime();

	// Validate the operation type
	if (!is_valid_operation(operation_type))
	{
		log("Operation type not found. Returning OPERATION_NOT_PERMITTED", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, access_token.get_lifetime());
		result = strdup(ResponseCodes::getString(ResponseCodes::OPERATION_NOT_PERMITTED).c_str());
		return &result;
	}

	// Validate the resource
	if (!is_valid_resource(resource))
	{
		log("Resource not found", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, access_token.get_lifetime());
		result = strdup(ResponseCodes::getString(ResponseCodes::RESOURCE_NOT_FOUND).c_str());
		return &result;
	}

	// Check if the user has the required approval
	if (has_required_approval(access_token, resource, operation_type))
	{
		log("User has the permission to perform the action", 2);
		log_validation_result("PERMIT", operation_type, resource, access_token_str, access_token.get_lifetime());
		result = strdup(ResponseCodes::getString(ResponseCodes::PERMISSION_GRANTED).c_str());
	}
	else
	{
		log("User does not have the permission to perform the action", 2);
		log_validation_result("DENY", operation_type, resource, access_token_str, access_token.get_lifetime());
		result = strdup(ResponseCodes::getString(ResponseCodes::OPERATION_NOT_PERMITTED).c_str());
	}

	return &result;
}

char **
approve_request_token_1_svc(request_authorization_t *argp, struct svc_req *rqstp)
{
	static char *result;

	std::string token_received = argp->authentification_token;
	std::string user_id_str = argp->user_id;
	int refresh_token = argp->refresh_token;

	log("========= APPROVE REQUEST TOKEN =========", 2);
	log("Request signature for token: " + token_received + " for user " + user_id_str + " with refresh token " + std::to_string(refresh_token), 2);

	// if we find the token in the list
	for (Token token : auth_token_list)
	{
		if (token.get_token() == token_received)
		{
			// if the token is signed
			if (token.get_status() == Token::AUTH_SIGNED)
			{
				log("Token already signed. Returning the token", 2);
				// return the token
				strcpy(result, token.get_token().c_str());
				return &result;
			}
			else
			{
				log("Found token as not signed. Signing the token", 2);
				// based on the approvals the user has in user_to_approvals_list, add them to the token
				// make user_id from argp string
				std::unordered_map<std::string, std::string> approvals = user_to_approvals_list.back();
				user_to_approvals_list.pop_back();

				// if there are no approvals return token as unsigned
				if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
				{
					log("No approvals found for user " + user_id_str, 2);
					strcpy(result, token_received.c_str());
					return &result;
				}

				log("Adding approvals to token for user " + user_id_str, 2);
				token.add_approvals(approvals);

				// if the token is unsigned, sign it
				log("Signing the token and returning it", 2);
				token.sign();

				// return the token
				strcpy(result, token.get_token().c_str());
				return &result;
			}
		}
	}

	// return the token unchanged if no approvals are to be added
	log("Token not found. Adding it to the list", 2);
	Token token = Token(argp->authentification_token, user_id_str, global_token_lifetime, Token::AUTH_UNSIGNED);

	// based on the approvals the user has in user_to_approvals_list, add them to the token
	std::unordered_map<std::string, std::string> approvals = user_to_approvals_list[0];
	user_to_approvals_list.erase(user_to_approvals_list.begin());

	// if there are no approvals return token as unsigned
	if (approvals.empty() || (approvals.find("*") != approvals.end() && approvals["*"] == "-"))
	{
		log("No approvals found for user " + user_id_str, 2);
		strcpy(result, token_received.c_str());
		return &result;
	}

	log("Adding approvals to token for user " + user_id_str, 2);
	token.add_approvals(approvals);

	// if the token is unsigned, sign it
	log("Signing the token and returning it", 2);
	token.sign();

	// add the token to the list
	auth_token_list.push_back(token);

	std::string result_str = token.get_token();
	result = strdup(result_str.c_str());

	return &result;
}

access_token_t *
refresh_access_1_svc(access_token_t *argp, struct svc_req *rqstp)
{
	// find the user id based on the access token
	std::string user_id;
	for (auto const &user_access_token : user_to_access_token)
	{
		Token user_access_token_i = user_access_token.second;
		if (user_access_token_i.get_token() == argp->access_token)
		{
			user_id = user_access_token.first;
			break;
		}
	}

	// log in stream 0 BEGIN user_id AUTHZ REFRESH
	log("BEGIN " + user_id + " AUTHZ REFRESH", 0);
	static access_token_t result;

	// parse the arguments
	std::string access_token_str = argp->access_token;
	std::string refresh_token_str = argp->refresh_token;

	log("========= REFRESH ACCESS TOKEN =========", 2);
	log("Refresh access token with access token " + access_token_str + " and refresh token " + refresh_token_str, 2);

	// find the access token in the user_to_access_token map
	for (auto const &user_access_token : user_to_access_token)
	{
		Token user_access_token_i = user_access_token.second;
		if (user_access_token_i.get_token() == access_token_str)
		{
			log("Access token found. Refreshing it", 2);

			// generate a new access token
			std::string new_access_token = generate_access_token(strdup(refresh_token_str.c_str()));

			// generate a new refresh token
			std::string new_refresh_token = generate_access_token(strdup(new_access_token.c_str()));

			// generate a new access token instance
			Token new_access_token_i = Token(new_access_token, new_refresh_token, user_access_token_i.get_user_id(), global_token_lifetime, Token::ACCESS);
			new_access_token_i.copy_all_approvals(user_access_token_i);

			// update the access token in the user_to_access_token map
			user_to_access_token[user_access_token.first] = new_access_token_i;

			// return the new access token
			result.access_token = strdup(new_access_token.c_str());
			result.refresh_token = strdup(new_refresh_token.c_str());
			result.expiration = global_token_lifetime;

			log("  AccessToken = " + new_access_token, 0);
			log("  RefreshToken = " + new_refresh_token, 0);

			return &result;
		}
	}

	// if the access token is not found return an error
	log("Access token not found. Could not refresh it", 2);
	result.access_token = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
	result.refresh_token = strdup(ResponseCodes::getString(ResponseCodes::TOKEN_EXPIRED).c_str());
	result.expiration = -1;

	return &result;
}
